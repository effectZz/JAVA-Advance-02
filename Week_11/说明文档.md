## 文档



对应题的文件夹里有noX.txt对项目的补充说明



#### No1

按照课程内容，动手验证 Hibernate 和 Mybatis 缓存。

路径：src/main/java/com/example/demo/no1



yml配置：添加了二级缓存

```yaml
mybatis:
  mapper-locations: classpath:mybatis/*Mapper.xml
  type-aliases-package: com.example.demo.no1.entity
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    cache-enabled: true
    local-cache-scope: session
```



在对应的xml文件里添加了

···

<cache/>

···

```
<cache
    ``type = ``"org.mybatis.caches.ehcache.LoggingEhcache"` `//指定使用的缓存类，mybatis默认使用HashMap进行缓存,可以指定第三方缓存
    ``eviction = ``"LRU"` `//默认是 LRU 淘汰缓存的算法，有如下几种：
             ``//1.LRU – 最近最少使用的:移除最长时间不被使用的对象。
             ``//2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 
             ``//3.SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 
             ``//4.WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象
    ``flushInterval = ``"1000"` `//清空缓存的时间间隔，单位毫秒，可以被设置为任意的正整数。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。
    ``size = ``"100"`   `//缓存对象的个数，任意正整数，默认值是1024。
    ``readOnly = ``"true"` `//缓存是否只读，提高读取效率
    ``blocking = ``"true"`  `//是否使用阻塞缓存，默认为false，当指定为true时将采用BlockingCache进行封装，blocking，
              ``//阻塞的意思，使用BlockingCache会在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，
              ``//否则会在查询数据库以后再释放锁这样可以阻止并发情况下多个线程同时查询数据，详情可参考BlockingCache的源码。 
/>
```

可以看到SQL日志，当运行第二次时已经没有去查询SQL了

```
JDBC Connection [HikariProxyConnection@1006756655 wrapping com.mysql.cj.jdbc.ConnectionImpl@1e946c4a] will not be managed by Spring
==>  Preparing: select * from user where id = ?
==> Parameters: 1(Integer)
<==    Columns: id, name, age
<==        Row: 1, aaa, 12
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@39c2a10e]
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@790b52d4] was not registered for synchronization because synchronization is not active
As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66
Cache Hit Ratio [com.example.demo.no1.mapper.UserMapper]: 0.5
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@790b52d4]
```





#### No4

```
4.自己动手设计一个简单的 cache，实现过期策略。

用一个静态的map当缓存
利用线程池控制时间。
可以存obj，并且有过期时间。
```

路径：src/main/java/com/example/demo/no4





#### No6

分别基于 jedis，RedisTemplate，Lettuce，Redission 实现 redis 基本操作的 demo，可以使用 spring-boot 集成上述工具。





目前这里只用了RedisTemplate做一个简单的测试，第八题用了jedis

目录：src/main/java/com/example/demo/no6/redisTemplate/MyRedisTemplateTest.java

测试类：

src/test/java/com/example/demo/no6/redisTemplate/MyRedisTemplateTestTest.java



读取了刚刚命令输入的key值，

并且添加了一个有效期为1分钟的值。





#### No8（必做）

基于 Redis 封装分布式数据操作：

在 Java 中实现一个简单的分布式锁；
在 Java 中实现一个分布式计数器，模拟减库存。



目录：src/main/java/com/example/demo/no8/

锁类：RedisLock

单例的类，使用Jedis，两个方法加锁和解锁。



实现类：DemoReduce

初始10个库存，模拟减少1，创建了3个线程模拟减库存

主线程用了join分别去等待，运行可以看到库存是减少的。



注释掉了使用CountDownLatch方式调用。





#### No9

基于 Redis 的 PubSub 实现订单异步处理



类：

Pub  发布者循环10次  模拟了10次调用订单，并将次数发布到channel

Sub 订阅者 。 因为Jedis的subscribe操作是阻塞的所以不需要单独处理

PubSubService   测试实现。





路径：src/main/java/com/example/demo/no9